# Алгоритм управления памятью близнецы + SLAB
Омельян Е.В
# Выделение/распределение памяти
RAM устроена довольно сложно, она иерархична (многоэтажна). ОП разделяют на несколько типов. Деление это обусловлено историческими причинами.

Выделяют 4 вида памяти:
- Стандартная (conventional memory area);
- Верхняя (upper memory blocks(area));
- Дополнительная (expanded memory specification);
- Расширенная (extended memory specification).
Стандартная (conventional memory area) - базовая, первые 640 Кб, также его часто называют lower. В мл. адреса этой памяти загружается ОС и драйверы устройств. Оставшуюся свободную часть памяти занимают пользовательские программы. Резидентные программы так же остаются в этой памяти.

Верхняя (upper memory аrea) - 640Кб - 1Мб используется для хранения служебной информации: памяти видеоадаптера, BIOS. Спец. драйвер Himem.sys позволяют загружать в свободные участки этой области резидентные программы и драйвера устройств.

High memory - первые 64 Кб после 1Мб. ОС MS DOS позволяет загрузить часть резидентной DOS в эту область, освобождая при этом существенную часть базовой памяти для работы прикладных программ. Особенно это полезно для программ, использующих всю ОП. Используя спец. утилиты (для DOS emm386.exe) в верхние разделы памяти можно загружать также и резидентные программы (команды LH для autoexec.bat и DEVICEHIGT для config.sys).

Вся память свыше 1 Мб может быть рассмотрена как дополнительная (expanded) или какрасширенная (extended). В ОС менеджер памяти позволяет использовать память и как расширенную и как дополнительную, автоматически обеспечивая тот тип взаимодействия с данными, который нужен прикладным программам. Т.е. пользователю новых современных ПК (от Pentium) нет необходимости распределять память «в ручную», менеджер выделить память таким образом, как это требует прикладная программа.

Дополнительная(expanded) память - постраничная, т.е. ОП разбивается на страницы, каждой странице ставится в соответствие определенный адрес в основной памяти. При обращении к такому адресу EMM(expanded memory manager) драйвер расширенной памяти(менеджер памяти) позволяет компьютеру считать информацию с соответствующей страницы памяти.

Расширенная (extended) память построчной организации (Smartdrv - драйвер расширенной памяти) используется для создания временного логического диска (виртуального диска), как буфер обмена с жестким диском.

# Метод близнецов (Buddy system) 
Является схемой выделения памяти, сочетающей в себе возможность слияния буферов и распределитель по степени числа 21 [13]. В основе метода лежит создание буферов малого размера путем деления пополам больших буферов и слияния смежных буферов по мере возможности. При разделении буфера на два каждая половина называется близнецом (buddy) второй.

По словам Дональда Кнута , система близнецов была изобретена в 1963 году Гарри Марковицем и впервые описана Кеннетом К. Ноултоном (опубликовано в 1965 году). Выделение памяти Buddy относительно легко реализовать. Он поддерживает ограниченное, но эффективное разделение и объединение блоков памяти.

Предыдущая реализация malloc для FreeBSD от Kamp (1998), обычно называемая phkmalloc,долгое время считался одним из лучших доступных и хорошо зарекомендовал себя в опубликованных сравнениях (Fengи Бергер, 2005 г.; Бергер и др., 2000; Бора и Габбер, 2001). Тем не менее, он был разработан в то время когда многопроцессорные системы были редкостью, а поддержка многопоточности была неравномерной. FreeBSDпроект постоянно работает над обеспечением масштабируемой производительности в SMP-системах и имеетдостигли такого прогресса, что malloc стал узким местом масштабируемости для некоторых многопоточных

По сравнению с другими более простыми методами, такими как динамическое выделение , система памяти имеет небольшую внешнюю фрагментацию и позволяет сжимать память с небольшими накладными расходами. Метод освобождения памяти быстрый, с максимальным требуемым количеством сжатий, равным log 2 (самый высший порядок). Как правило, система распределения памяти близнецов реализуется с использованием двоичного дерева для представления используемых или неиспользуемых разделенных блоков памяти
Однако по-прежнему существует проблема внутренней фрагментации — трата памяти впустую, потому что запрашиваемая память немного больше, чем маленький блок памяти, но намного меньше, чем большой блок памяти. Из-за того, как работает метод распределения памяти, программе, которая запрашивает 66 КБ памяти, будет выделено 128 КБ, что приведет к потере 62 КБ памяти. Эта проблема может быть решена с помощью slab-аллокации , которая может быть наложена поверх более грубого распределителя друзей, чтобы обеспечить более мелкозернистое распределение.

Одна из версий алгоритма распределения близнецов была подробно описана Дональдом Кнутом в первом томе книги «Искусство компьютерного программирования» . 

# Распределение slab (от англ. slab — брусок, плита)
Механизм управления памятью, предназначенный для более эффективного распределения памяти и устранения значительной фрагментации. Основой этого алгоритма является сохранение выделенной памяти, содержащей объект определённого типа, и повторное использование этой памяти при следующем выделении для объекта того же типа. Этот метод был впервые введен в SunOS Джефом Бонвиком и сейчас широко используется в ядрах многих операционных системах Unix, включая FreeBSD и Linux. Ядро Linux помимио slab также использует систему близнецов с дальнейшими модификациями для минимизации внешней фрагментации, а также различные другие распределители для управления памятью внутри блоков. 

Понимание алгоритма распределения плит требует определения и объяснения некоторых терминов:

Slab(плита) : плита представляет собой непрерывную часть памяти, обычно состоящую из нескольких физически смежных страниц. Плита — это фактический контейнер данных, связанных с объектами определенного типа содержащего кэша. Когда программа настраивает кеш, она распределяет ряд объектов по блокам, связанным с этим кешем. Это число зависит от размера связанных плит.

Плиты могут находиться в одном из следующих состояний:

- empty  — все объекты на плите помечены как свободные
- partial  – плита состоит как из используемых, так и из свободных объектов
- full  — все объекты на плите помечены как используемые

Изначально система помечает каждую плиту как «пустую». Когда процесс вызывает новый объект ядра, система пытается найти свободное место для этого объекта на неполной плите в кэше для этого типа объекта. Если такого местоположения не существует, система выделяет новый блок из смежных физических страниц и назначает его кэшу. Новый объект выделяется из этой плиты, и его местоположение становится помеченным как «частичное». 

# Математическая модель алгоритма близнецы

Ниже приведен пример того, что происходит, когда программа запрашивает память. Допустим, в этой системе наименьший возможный блок имеет размер 64 килобайта, а верхний предел для порядка равен 4, что приводит к максимальному размеру выделяемого блока, 24 умноженного на 64 КБ = 1024 КБ. 

Ниже показано возможное состояние системы после различных запросов памяти.

1. attocate(256). Блок делится на два близнеца, А и А'; блок А' поступает в список свободных 512-байтовых буферов. Затем буфер А разбивается на В и В'. В' заносится в список свободных 256-байтных буферов, а буфер В передается клиенту.

2. attocate(128). Распределитель обнаруживает, что список свободных 128-байтовых буферов пуст. Тогда он проверяет список 256-байтовых буферов, изымает оттуда В' и разделяет его на С и С'. После этого буфер С' помещается в список свободных 128-байтовых буферов, а буфер В возвращается клиенту.
Выше описывается двоичная методика близнецов, которая является наиболее простой и популярной из систем близнецов. На самом деле можно реализовать и другие варианты алгоритма, разделяющие буферы на четыре, восемь и более частей.

Пример реализации:
----
Идея этого алгоритма состоит в том, что организуются списки свободных блоков отдельно для каждого размера
2k, 0 <= k <= m.
Вся область памяти кучи состоит из 2^m слов, которые, можно считать, имеют адреса с 0 по 2^m– 1.
Первоначально свободным является весь блок из 2m слов. 

Далее, когда требуется блок из 2^k слов, а свободных блоков такого размера нет, расщепляется на две равные части блок большего размера; в результате появится блок размера 2^k (т.е. все блоки имеют длину, кратную 2). 

Когда один блок расщепляется на два (каждый из которых равен половине первоначального), эти два блока называются близнецами. Позднее, когда оба близнеца освобождаются, они опять объединяются в один блок. 

Преимуществом этого алгоритма является скорость, но его реализация усложняется за счет необходимости вести систему списков свободных блоков.

# Математическая модель Slab
 - Большие slab’ы

Предназначены для кэшей, хранящих объекты, размер которых не менее 1/8 размера страницы памяти данной машины. Большие slab’ы имеют структуру, отличную от небольших slab’ов, чтобы лучше умещаться на страницах памяти, таким образом избегая фрагментации. Slab содержит список буферных контроллеров, которые являются контроллерами для каждого буфера, который может быть выделен (буфер — это память, которую пользователь распределителя slab будет использовать).
- Малые slab’ы

Содержат объекты, которые не превышают 1/8 размера страницы памяти данной машины. Они должны быть оптимизированы отдельно от логической структуры, избегая использования буферных контроллеров (которые были бы такими же большими, как и данные в них, вызывая тем самым намного больший расход памяти). Небольшие slab’ы занимают точно одну страницу, и имеют определённую структуру, позволяющую им избежать буферизации. Последняя часть страницы содержит «заголовок slab», представляющий собой информацию, необходимую для хранения slab’а. Начиная с первого адреса страницы, есть столько буферов, сколько может быть выделено без использования заголовка slab в конце страницы.

Вместо обычного использования буферных контроллеров, используется буфер для хранения списка свободных ссылок. Это позволяет обходиться без использования буферных контроллеров в небольших slab’ах.

Понимание алгоритма распределения плит требует определения и объяснения некоторых терминов:

- Кэш : кеш представляет небольшой объем очень быстрой памяти. Кэш — это хранилище для объектов определенного типа , таких как семафоры , дескрипторы процессов , файловые объекты и т. д.
- Slab(плита) : плита представляет собой непрерывную часть памяти, обычно состоящую из нескольких физически смежных страниц. Плита — это фактический контейнер данных, связанных с объектами определенного типа содержащего кэша. Когда программа настраивает кеш, она распределяет ряд объектов по блокам, связанным с этим кешем. Это число зависит от размера связанных плит.

Плиты могут находиться в одном из следующих состояний:

empty  — все объекты на плите помечены как свободные

partial  – плита состоит как из используемых, так и из свободных объектов

full  — все объекты на плите помечены как используемые

Изначально система помечает каждую плиту как «пустую». Когда процесс вызывает новый объект ядра, система пытается найти свободное место для этого объекта на неполной плите в кэше для этого типа объекта. Если такого местоположения не существует, система выделяет новый блок из смежных физических страниц и назначает его кэшу. Новый объект выделяется из этой плиты, и его местоположение становится помеченным как «частичное».

Распределение происходит быстро, потому что система заранее строит объекты и легко выделяет их из плиты.

# Список литературы:

For Memory Management Algorithm: Twins:

1.	http://www.mosiui.ru/033 
2.	https://people.freebsd.org/~jasone/jemalloc/bsdcan2006/jemalloc.pdf 
3.	https://en.wikipedia.org/wiki/Buddy_memory_allocation 
4.	https://en.wikipedia.org/wiki/The_Art_of_Computer_Programming 
5.	https://www.geeksforgeeks.org/buddy-system-memory-allocation-technique/ 
6.	https://www.cs.fsu.edu/~engelen/courses/COP402003/p827.pdf 
7.	http://os.osll.ru/tpost/riobzbj3dk-buddy-memory-allocation 
8.	https://studfile.net/preview/2114414/page:19/ 
9.	https://cyberpedia.su/27xd601.html 
10.	https://studfile.net/preview/16568116/page:62/ 
11.	https://studfile.net/preview/16568116/page:63/ 
12.	https://web.archive.org/web/20071011171817/http://ibm.com/developerworks/linux/library/l-linux-slab-allocator/index.html 
13.	https://en.wikipedia.org/wiki/Stack-based_memory_allocation 
14.	https://en.wikipedia.org/wiki/Memory_pool 
15.	https://svnbook.red-bean.com/en/1.1/ch08s05.html 
16.	https://www.pjsip.org/pjlib/docs/html/group__PJ__POOL__GROUP.htm 
17.	https://www.youtube.com/watch?v=t49Vgj5MvMg 

For Slab:

18.	https://www.ibm.com/developerwor    ks/ru/library/l-linux-slab-allocator/
19.	https://web.archive.org/web/20071011171817/http://ibm.com/developerworks/linux/library/l-linux-slab-allocator/index.html - M. Tim Jones (Emulex Corp), 15 May 2007
20.	https://web.archive.org/web/20160831101859/http://k806.ru/osprogram/os_2011-11-12.pdf#page=26 – Выделение память ядром 2011/12
21.	https://ru.wikipedia.org/wiki/Slab 
22.	https://wiki.csiamerica.com/display/safe/Modeling+slabs+with+variable+thickness%2C+loading+and+soil+subgrade++modulus 
23.	https://github.com/miloskalicanin/Slab-allocator/tree/master/src 
24.	http://os.osll.ru/tpost/sapm6ygzxh-slab-allocation 
25.	https://russianblogs.com/article/6796303641/ 
26.	https://elixir.bootlin.com/linux/v4.7/source/mm/slab.h#L417 – реализация через Linux
27.	https://en.wikipedia.org/wiki/Slab_allocation 
28.	https://lwn.net/Articles/229984/ 
 
# Приложение


Системы, использующие распределение плит
-	AmigaOS (представлена в AmigaOS 4 )
-	DragonFly BSD (представлен в версии 1.0)
- FreeBSD (представлено в версии 5.0)
-	GNU Мах [5]
-	Хайку (введено в альфа 2)
-	Horizon ( микроядро Nintendo Switch ) [6]
-	HP-UX (представлен в версии 11i) [7]
- Linux (представленный в ядре 2.2, теперь это одна из трех реализаций распределителя памяти вместе с SLOB и SLUB . Три распределителя
